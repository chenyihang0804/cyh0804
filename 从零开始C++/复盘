1. 局部变量和静态局部变量的区别：
1）局部变量储存在栈区；栈区由编译器自动分配释放；局部作用域，只在函数执行期间存在，函数一次调用结束后变量就被撤销，所占内存被回收；
2）局部静态变量储存在静态区；静态区在程序结束后由系统释放；局部作用域，只被初始化一次，只对定义自己的函数体可见；
3）全局变量储存在静态区的常量区；具有全局作用域；
4）全局静态变量储存在静态区；全局作用域，作用于定义它的文件里，不能作用到其他文件，即被static修饰后具有文件作用域性质，即使两个文件定了相同的静态全局变
量，也是不同的变量。

2. C++多态，虚函数，纯虚函数的理解：
纯虚函数：为了方便使用多态，并且很多时候基类生成对象是不合理的。
1）纯虚函数一定没有定义；只是用来规范派生类的行为，可以理解为一个接口；
2）定义了纯虚函数的基类就是抽象基类，抽象类不能定义实例，但可以指向实现这个抽象类的具体类的指针或引用；（让基类不可实例化）
3）实现了纯虚函数的子类，在子类里纯虚函数就变成了虚函数；
4）定义纯虚函数的目的在于告诉子类必须为纯虚函数提供一个实现；

虚函数：
1）C++实现多态的机制；（通过基类访问派生类的定义的函数）
2）析构函数必须是虚函数，调用相应类型的析构函数，如果指针指向子类对象，调用子类对象的析构函数，然后自动调用基类的析构函数；
3）虚函数必须被实现，否则会报错；
4）父类和子类都有各自的版本，由多态方式调用的时候动态绑定；

多态：
1）如果一个指针指向子类的对象，那么他调用的就是子类对象的函数；
2）实现方式：子类和父类有同名同参数的函数。
3）通过指针找到对象，再找到对象中的虚表，在虚表里找到该调用的函数调用的函数指针，所以必须等到指针创建出来之后，才能去指向的对象里查找，所以必须采用动态
联编。在运行的时候决定调用哪个函数；
4）子类重写父类的方法的时候，同时是把继承自父类虚表中函数的索引的函数指针从父类的函数改写成了子类的函数，所以造成了父类和子类虚表里的内容不同，动态联编时
就去父类或者子类虚表里查询，调用的函数就不相同，就形成了多态的效果；（vtpl虚表指针）
5）官方使用virtual实现创建虚表以及继承等一系列工作；

3. 智能指针的底层原理：

4. 实现一个指针指针的类

5. 实现内存对齐
